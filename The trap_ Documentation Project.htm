<html>
<head>
<title>The trap_* Documentation Project sorted by [PR]JazzD</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#FF0000" vlink="#FF0000" alink="#FF0000">
<div align="center"> 
  <p><font face="Tahoma" size="4"><u>The Quake3 Code trap_* Documentation Project:</u></font><br>
    <font size="3" face="Tahoma" color="#330099">sorted by JazzD 2002</font></p>
  <p>&nbsp;</p>
  <p><font face="Tahoma" size="3">This document was created was created by many 
    people at Quake3World.com modifications programming forum.<br>
    We collected mostly all trap_* functions of the code and now try to explain 
    them to get them more clear for any use<br>
    inside the code. If you want to make this document famous and known please 
    link it up everywhere you can. Thank you.<br>
    </font></p>
  <p>&nbsp;</p>
  <p><font face="Tahoma" size="3">=) sorted for you by JazzD , because some guys 
    said that it's unuseable inside the forums.</font></p>
  <p><font face="Tahoma" size="3">These information about the trap_s* were collected 
    by:<br>
    Timbo, Hunter-Killer , Die , D!ABLO, FonFon, RR2DO2, PhaethonH.</font></p>
  <p><font face="Tahoma" size="3">Thanks.<br>
    <br>
    Okay I make a small list with links to the functions.</font></p>
  <p><font face="Tahoma" size="3">If the function isn't as a link yet then there 
    is just no description yet!</font></p>
  <p><font face="Tahoma" size="3">If you have any comments contact me at: <a href="mailto:jazzd@prsoftware.de">jazzd@prsoftware.de</a></font></p>
  <p>&nbsp;</p>
  <p align="left">&nbsp;</p>
  <p align="left"><b><font face="Tahoma" size="2">GAME</font></b></p>
  <p align="left"><font face="Tahoma" size="2"><a href="#printf">trap_Printf</a><br>
    <a href="#error">trap_Error</a><br>
    <a href="#milliseconds">trap_Milliseconds</a><br>
    <a href="#Cvar_Register">trap_Cvar_Register</a><br>
    <a href="#Cvar_update">trap_Cvar_Update</a><br>
    <a href="#Cvar_set">trap_Cvar_Set</a><br>
    <a href="#Cvar_Variable_IntegerValue">trap_Cvar_VariableIntegerValue</a><br>
    <a href="#VariableStringBuffer">trap_Cvar_VariableStringBuffer</a><br>
    <a href="#Argc">trap_Argc</a><br>
    <a href="#argv">trap_Argv</a><br>
    <a href="#FOpenFile">trap_FS_FOpenFile</a><br>
    <a href="#Read">trap_FS_Read</a><br>
    <a href="#Write">trap_FS_Write</a><br>
    <a href="#FCloseFile">trap_FS_FCloseFile</a><br>
    <a href="#SendConsoleCommand">trap_SendConsoleCommand</a><br>
    <a href="#LocateGameData">trap_LocateGameData</a><br>
    <a href="#DropClient">trap_DropClient</a><br>
    <a href="#SendServerCommand">trap_SendServerCommand</a><br>
    <a href="#SetConfigString">trap_SetConfigstring</a><br>
    <a href="#GetConfigString">trap_GetConfigstring</a><br>
    <a href="#GetUserinfo">trap_GetUserinfo</a><br>
    <a href="#SetUserinfo">trap_SetUserinfo</a><br>
    <a href="#GetServerinfo">trap_GetServerinfo</a><br>
    trap_SetBrushModel<br>
    <a href="#Trace">trap_Trace</a><br>
    <a href="#PointContents">trap_PointContents</a><br>
    <a href="#InPVS">trap_InPVS</a><br>
    <a href="#InPVSIgnorePortals">trap_InPVSIgnorePortals</a><br>
    trap_<a href="#AdjustAreaPortalState">AdjustAreaPortalState</a><br>
    trap_<a href="#AreasConnected">AreasConnected</a><br>
    trap_<a href="#LinkEntity">LinkEntity</a><br>
    trap_<a href="#UnlinkEntity">UnlinkEntity</a><br>
    trap_<a href="#EntitiesInBox">EntitiesInBox</a><br>
    trap_<a href="#EntityContact">EntityContact</a><br>
    trap_<a href="#GetUsercmd">GetUsercmd</a><br>
    trap_<a href="#GetUsercmd">GetEntityToken</a><br>
    trap_<a href="#FS_GetFileList">FS_GetFileList</a><br>
    trap_<a href="#DebugPolygonCreate">DebugPolygonCreate</a><br>
    trap_<a href="#DebugPolygonDelete">DebugPolygonDelete</a><br>
    trap_<a href="#RealTime">RealTime</a><br>
    trap_<a href="#SnapVector">SnapVector</a></font></p>
  <p align="left"><font face="Tahoma" size="2"><b>CGAME</b></font></p>
  <p align="left"><font face="Tahoma" size="2">trap_<a href="#print">Print</a><br>
    trap_<a href="#Error">Error </a><br>
    trap_<a href="#Milliseconds">Milliseconds </a><br>
    trap_<a href="#Cvar_Register%20">Cvar_Register </a><br>
    trap_<a href="#Cvar_Update%20">Cvar_Update </a><br>
    trap_<a href="#Cvar_Update%20">Cvar_Set</a><br>
    trap_Cvar_VariableStringBuffer <br>
    trap_<a href="#Argc">Argc</a><br>
    trap_<a href="#Argv">Argv</a><br>
    trap_<a href="#Args">Args</a><br>
    trap_FS_<a href="#FOpenFile">FOpenFile</a><br>
    trap_FS_<a href="#Read">Read</a><br>
    trap_FS_<a href="#Write">Write</a><br>
    trap_FS_<a href="#FCloseFile">FCloseFile</a><br>
    trap_<a href="#SendConsoleCommand%20">SendConsoleCommand </a><br>
    trap_AddCommand <br>
    trap_SendClientCommand <br>
    trap_UpdateScreen <br>
    trap_CM_LoadMap <br>
    trap_CM_NumInlineModels <br>
    trap_CM_InlineModel <br>
    trap_CM_LoadModel <br>
    trap_CM_TempBoxModel <br>
    trap_CM_PointContents <br>
    trap_CM_TransformedPointContents <br>
    trap_CM_BoxTrace <br>
    trap_CM_TransformedBoxTrace <br>
    trap_CM_MarkFragments <br>
    trap_S_StartSound <br>
    trap_S_StartLocalSound <br>
    trap_S_ClearLoopingSounds <br>
    trap_S_AddLoopingSound <br>
    trap_S_UpdateEntityPosition <br>
    trap_S_Respatialize <br>
    trap_S_RegisterSound <br>
    trap_S_StartBackgroundTrack <br>
    trap_R_LoadWorldMap <br>
    trap_R_RegisterModel <br>
    trap_R_RegisterSkin <br>
    trap_R_RegisterShader <br>
    trap_R_ClearScene <br>
    trap_R_AddRefEntityToScene <br>
    trap_R_AddPolyToScene <br>
    trap_R_AddLightToScene <br>
    trap_R_RenderScene <br>
    trap_R_SetColor <br>
    trap_R_DrawStretchPic <br>
    trap_R_ModelBounds <br>
    trap_R_LerpTag <br>
    trap_GetGlconfig <br>
    trap_GetGameState <br>
    trap_GetCurrentSnapshotNumber <br>
    trap_GetSnapshot <br>
    trap_GetServerCommand <br>
    trap_GetCurrentCmdNumber <br>
    trap_GetUserCmd <br>
    trap_SetUserCmdValue <br>
    trap_R_RegisterShaderNoMip <br>
    trap_MemoryRemaining <br>
    trap_R_RegisterFont<br>
    trap_Key_IsDown <br>
    trap_Key_GetCatcher <br>
    trap_Key_SetCatcher<br>
    trap_Key_GetKey <br>
    trap_PC_AddGlobalDefine<br>
    trap_PC_LoadSource <br>
    trap_PC_FreeSource<br>
    trap_PC_ReadToken <br>
    trap_PC_SourceFileAndLine <br>
    trap_S_StopBackgroundTrack<br>
    trap_<a href="#RealTime%20">RealTime </a><br>
    trap_<a href="#RealTime%20">SnapVector </a><br>
    trap_RemoveCommand <br>
    trap_R_LightForPoint <br>
    trap_CIN_<a href="#PlayCinematic%20">PlayCinematic </a><br>
    trap_CIN_<a href="#StopCinematic">StopCinematic</a><br>
    trap_CIN_<a href="#RunCinematic%20">RunCinematic </a><br>
    trap_CIN_<a href="#StopCinematic">DrawCinematic</a><br>
    trap_CIN_SetExtents<br>
    trap_R_RemapShader <br>
    trap_S_AddRealLoopingSound<br>
    trap_S_StopLoopingSound</font></p>
  <p align="left"><font face="Tahoma" size="2"><b>Q3UI</b></font></p>
  <p align="left"><font face="Tahoma" size="2">trap_<a href="#Error">Error</a><br>
    trap_<a href="#Print">Print</a><br>
    trap_<a href="#Milliseconds">Milliseconds</a><br>
    trap_Cvar_Set<br>
    trap_Cvar_VariableValue<br>
    trap_Cvar_VariableStringBuffer<br>
    trap_Cvar_SetValue<br>
    trap_Cvar_Reset<br>
    trap_Cvar_Create<br>
    trap_Cvar_InfoStringBuffer<br>
    trap_<a href="#Argc">Argc</a><br>
    trap_<a href="#Argv">Argv</a><br>
    trap_Cmd_ExecuteText<br>
    trap_FS_<a href="#FOpenFile">FOpenFile</a><br>
    trap_FS_<a href="#Read">Read</a><br>
    trap_FS_<a href="#Write">Write</a><br>
    trap_FS_<a href="#FCloseFile">FCloseFile</a><br>
    trap_FS_GetFileList<br>
    trap_R_RegisterModel<br>
    trap_R_RegisterSkin<br>
    trap_R_RegisterShaderNoMip<br>
    trap_R_ClearScene<br>
    trap_R_AddRefEntityToScene<br>
    trap_R_AddPolyToScene<br>
    trap_R_AddLightToScene<br>
    trap_R_RenderScene<br>
    trap_R_SetColor<br>
    trap_R_DrawStretchPic<br>
    trap_UpdateScreen<br>
    trap_CM_LerpTag<br>
    trap_CM_LoadModel<br>
    trap_S_RegisterSound<br>
    trap_S_StartLocalSound<br>
    trap_Key_KeynumToStringBuf<br>
    trap_Key_GetBindingBuf<br>
    trap_Key_SetBinding<br>
    trap_Key_IsDown<br>
    trap_Key_GetOverstrikeMode<br>
    trap_Key_SetOverstrikeMode<br>
    trap_Key_ClearStates<br>
    trap_Key_GetCatcher<br>
    trap_Key_SetCatcher<br>
    trap_GetClipboardData<br>
    trap_GetGlconfig<br>
    trap_GetClientState<br>
    trap_GetConfigString<br>
    trap_LAN_GetPingQueueCount<br>
    trap_LAN_ClearPing<br>
    trap_LAN_GetPing<br>
    trap_LAN_GetPingInfo<br>
    trap_Cvar_Register<br>
    trap_Cvar_Update<br>
    trap_MemoryRemaining<br>
    trap_GetCDKey<br>
    trap_SetCDKey<br>
    trap_R_RegisterFont<br>
    trap_R_ModelBounds<br>
    trap_PC_AddGlobalDefine<br>
    trap_PC_LoadSource<br>
    trap_PC_FreeSource<br>
    trap_PC_ReadToken<br>
    trap_PC_SourceFileAndLine<br>
    trap_S_StopBackgroundTrack<br>
    trap_S_StartBackgroundTrack<br>
    trap_RealTime<br>
    trap_LAN_GetServerCount<br>
    trap_LAN_GetServerAddressString<br>
    trap_LAN_GetServerInfo<br>
    trap_LAN_MarkServerVisible<br>
    trap_LAN_UpdateVisiblePings<br>
    trap_LAN_ResetPings<br>
    trap_LAN_LoadCachedServers<br>
    trap_LAN_SaveCachedServers<br>
    trap_LAN_AddServer<br>
    trap_LAN_RemoveServer<br>
    trap_CIN_PlayCinematic<br>
    trap_CIN_StopCinematic<br>
    trap_CIN_RunCinematic<br>
    trap_CIN_DrawCinematic<br>
    trap_CIN_SetExtents<br>
    trap_R_RemapShader<br>
    trap_VerifyCDKey<br>
    trap_LAN_ServerStatus<br>
    trap_LAN_GetServerPing<br>
    trap_LAN_ServerIsVisible<br>
    trap_LAN_CompareServers</font></p>
  <p align="left">&nbsp;</p>
  <font face="Tahoma" size="2"><a name="printf"></a> </font> 
  <hr>
  <div align="left"><font face="Tahoma" size="2">void trap_Printf( const char 
    *fmt )<br>
    const chat *fmt: Text to be displayed </font></div>
  <p align="left"><font face="Tahoma" size="2">Prints the string pointed to by 
    fmt to the Q3 Console. This should not usually be used directly by the user 
    - the G_Printf function provides its functionality and more.</font></p>
  <font face="Tahoma" size="2"><a name="error"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Error( const char *fmt 
    )<br>
    const chat *fmt: Text to be displayed</font></p>
  <p align="left"><font face="Tahoma" size="2">This is very simliar to the trap_Printf 
    function with the exception that this will halt execution of the module it 
    is called from. Usually the user shouldn't call this directly, but using G_Error 
    instead.</font></p>
  <font face="Tahoma" size="2"><a name="PointContents"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_PointContents( const vec3_t 
    point, int passEntityNum )<br>
    const vec3_t point: The point in space to be examined<br>
    int passEntityNum: An entityNum to be ignored.</font></p>
  <p align="left"><font face="Tahoma" size="2">This trap call returns the CONTENTS_* 
    of a specific point in space - it is commonly used to avoid spawning items 
    in CONTENTS_NODROP areas. The second parameter specifies an entityNum (ent-&gt;s.number) 
    which is ignored when evaluating the contents for a point.</font></p>
  <font face="Tahoma" size="2"><a name="SetConfigString"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_SetConfigstring( int 
    num, const char *string )<br>
    int num: The config string to set.<br>
    const char *string: The value to set it to.</font></p>
  <p align="left"><font face="Tahoma" size="2">The Q3 Engine provides a mechanism 
    for communicating data from the server to the client via config strings. This 
    is (presumably) an array of strings within the engine that are indexed by 
    the CS_* values in bg_public.c. This trap call sets one of these strings to 
    a value. Config strings should usually be used to communicate complex data 
    that changes relatively rarely.</font></p>
  <font face="Tahoma" size="2"><a name="GetConfigString"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_GetConfigstring( int 
    num, char *buffer, int bufferSize )<br>
    int num: The config string to be read<br>
    char *buffer: A pointer to a buffer to fill with the config string value.<br>
    int bufferSize: The size of the buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">This is a server side callback 
    used to get the value of a config string. It is only used once in the q3 source, 
    by the G_FindConfigstringIndex function which in turn is used by the G_ModelIndex 
    and G_SoundIndex functions.</font></p>
  <font face="Tahoma" size="2"><a name="EntitiesInBox"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_EntitiesInBox( const vec3_t 
    mins, const vec3_t maxs, int *list, int maxcount )<br>
    const vec3_t mins: Defines the position of the corner of a cuboid.<br>
    const vec3_t maxs: Defines the position of the opposite corner of this cuboid.<br>
    int *list: A pointer to a list of entityNum's.<br>
    int maxcount: The maximum number of entities to return.</font></p>
  <p align="left"><font face="Tahoma" size="2">This fills an array of ints with 
    the entity numbers (ent-&gt;s.number) of all the entities currently within 
    the cuboid defined by mins and maxs. This is useful because it runs native 
    and is hence significantly cheaper than doing something similar in the QVM.</font></p>
  <font face="Tahoma" size="2"><a name="Milliseconds"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_Milliseconds(void);<br>
    No arguments needed</font></p>
  <p align="left"><font face="Tahoma" size="2">Returns the number of milliseconds 
    that have elapsed since Quake 3 was executed. A Quake 3, multi-platform version 
    of the Win32 function timeGetTime, which also returns the number of milliseconds 
    since the program was executed.</font></p>
  <font face="Tahoma" size="2"><a name="Cvar_Register"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Cvar_Register(vmCvar_t 
    *cvar, const char *var_name, const char *value, int flags);<br>
    vmCvar_t *cvar: A pointer the location in which to store the local data.<br>
    const char *var_name: A null-terminated string that will be used to set the 
    vmCvar's name field.<br>
    const char *value: A null-terminated string that will be used to set both 
    the floating point and integer value fields of the vmCvar.</font></p>
  <p align="left"><font face="Tahoma" size="2">This function is used to create 
    a new vmCvar. It sends all the information to the engine's main database and 
    then it stores a local copy of the data into the vmCvar_t passed as the first 
    argument.</font></p>
  <font face="Tahoma" size="2"><a name="Cvar_Update"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Cvar_Update(vmCvar_t 
    *cvar);<br>
    vmCvar_t *cvar: A pointer to the vmCvar to update.</font></p>
  <p align="left"><font face="Tahoma" size="2">This function first parses out 
    the name of the vmCvar and then searches for the corresponding database entry. 
    Once it finds the vmCvar it will copy the &quot;master copy&quot; of the vmCvar 
    into the local address provided.</font></p>
  <font face="Tahoma" size="2"><a name="Cvar_Set"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Cvar_Set(const char *var_name, 
    const char *value);<br>
    const char *var_name: A null-terminated string containing the name of the 
    vmCvar to set.<br>
    const char *value: A null-terminated string containing the desired value.</font></p>
  <p align="left"><font face="Tahoma" size="2">This function searchs for the name 
    of the vmCvar and stores the value into both the float and integer fields 
    of the corresponding vmCvar entry. The only way to effectly change the value 
    of a vmCvar is to use this function, the ANSI storage operator only modifies 
    the local buffer and not the &quot;master copy&quot;.</font></p>
  <font face="Tahoma" size="2"><a name="Trace"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Trace( trace_t *results, 
    const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, 
    int passEntityNum, int contentmask );</font></p>
  <p align="left"><font face="Tahoma" size="2">trace_t *results: a pointer to 
    a variable of type trace_t where the result of the trace will be stored.<br>
    const vec3_t start: a vector representing the starting position of the trace.<br>
    const vec3_t mins: a vector representing the mins of the bounding box the 
    trace will have.<br>
    const vec3_t maxs: a vector representing the maxs of the bounding box the 
    trace will have.<br>
    const vec3_t end: a vector representing the end position of the trace (it's 
    destination).<br>
    int passEntityNum: the trace will not collide against the entity with this 
    number (usually set to the entity number of the entity that initiated the 
    trace so it won't collide against itself).<br>
    int contentmask: the content mask it should collide against. Use any of the 
    MASK_ or CONTENTS_ constants. You can logical OR several of them together 
    if needed.</font></p>
  <p align="left"><font face="Tahoma" size="2"><br>
    This function is used to trace from one position to another in the BSP tree 
    and store the results in a trace_t structure. The results consist of the following 
    information (where tr is a variable of type trace_t): </font></p>
  <p align="left"><font face="Tahoma" size="2">tr.allsolid: if this is qtrue then 
    the area (or some part of it) between the mins and maxs is inside a solid 
    (a brush). <br>
    tr.contents: the contents mask of the plane that the trace hit.<br>
    tr.endpos: position where the trace ended.<br>
    tr.entityNum: entity number of the entity that the trace hit (if it hit solid 
    geometry then this will equal ENTITYNUM_WORLD).<br>
    tr.fraction: this is the fraction of the vector between start and end where 
    the trace ended. Therefore if this is less than 1.0 the trace hit something.<br>
    tr.plane: contains information about the plane that was hit (most notably 
    the surface normal) stored in a cplane_t structure.<br>
    tr.startsolid: if this is qtrue then the trace started in a solid (brush).<br>
    tr.surfaceFlags: surfaceflags of the surface that was hit (look in surfaceflags.h 
    at the SURF_* constants to see the which ones there are). </font></p>
  <p align="left"><font face="Tahoma" size="2">If the mins and maxs are NULL then 
    the trace is treated as purely linear from point to point. If mins and maxs 
    are defined however a bounding box trace is performed whereby rather than 
    a point the entire bounding box is traced so that it is possible to detect 
    the collision between solid entities. For example, tracing directly downwards 
    onto a floor with mins and maxs set to { -15, -15, -15 } and { 15, 15, 15 
    } respectively starting at some point above the floor will result in a trace_t 
    with an endpoint 15 units from the floor.</font></p>
  <font face="Tahoma" size="2"><a name="Argc"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_Argc( void )<br>
    Whenever a client issues a console command it can have arguments passed with 
    it. This function returns the number of arguments identically to the argc 
    found in C programs with this prototype for main:</font></p>
  <p align="left"><font face="Tahoma" size="2">int main( int argc, char **argv 
    )</font></p>
  <font face="Tahoma" size="2"><a name="Argv"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Argv( int n, char *buffer, 
    int bufferLength )<br>
    int n: The argument number to return.<br>
    char *buffer: A point to a buffer to fill.<br>
    int bufferLength: The size of the buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">This will fill the buffer pointed 
    to by buffer with an argument to a client command where n is the argument 
    to return. 0 is the command itself, 1 is the first argument and so on... Very 
    similiar to char **argv in a C program.</font></p>
  <font face="Tahoma" size="2"><a name="VariableInteger"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_Cvar_VariableIntegerValue( 
    const char *var_name );<br>
    const char *var_name: A null-terminated string containing the name of the 
    vmCvar to retrieve a value from.</font></p>
  <p align="left"><font face="Tahoma" size="2">This function returns the integer 
    value of var_name that is currently stored in the &quot;master copy&quot;.</font></p>
  <font face="Tahoma" size="2"><a name="FOpenFile"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_FS_FOpenFile( const char 
    *qpath, fileHandle_t *f, fsMode_t mode )<br>
    const char *qpath: The file to be opened.<br>
    fileHandle_t *f: Reference to a local fileHandle_t.<br>
    fsMode_t mode: Mode to open the file in.</font></p>
  <p align="left"><font face="Tahoma" size="2">This opens a file specified by 
    the string qpath and allocates a fileHandle_t (just a typedef int) to that 
    file. This is then used in subsequent operations involving the file. The fsMode_t 
    enumeration refers to the mode the file is opened in. FS_READ for reading 
    the file. FS_WRITE will create the file qpath if it doesn't exist or 0 length 
    it if it does. FS_APPEND allows writing to the end of an existing file. FS_APPEND_SYNC 
    is similar to FS_APPEND except you can read from the file at the same time.</font></p>
  <p align="left"><font face="Tahoma" size="2">An int is returned representing 
    the length of the file being opened.</font></p>
  <font face="Tahoma" size="2"><a name="Read"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_FS_Read( void *buffer, 
    int len, fileHandle_t f )<br>
    void *buffer: A buffer to fill.<br>
    int len: The amount to read from the file.<br>
    fileHandle_t: A file handle provided by trap_FS_FOpenFile.</font></p>
  <p align="left"><font face="Tahoma" size="2">This reads len bytes of data from 
    the file specified by f and fills buffer with it.</font></p>
  <font face="Tahoma" size="2"><a name="Write"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_FS_Write( const void 
    *buffer, int len, fileHandle_t f )<br>
    const void *buffer: A buffer to read from.<br>
    int len: The amount to write to the file.<br>
    fileHandle_t: A file handle provided by trap_FS_FOpenFile.</font></p>
  <p align="left"><font face="Tahoma" size="2">This writes len bytes of data from 
    buffer to the file specified by f.</font></p>
  <font face="Tahoma" size="2"><a name="FCloseFile"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">trap_FS_FCloseFile( fileHandle_t 
    f )<br>
    fileHandle_t f: The file to be closed.</font></p>
  <p align="left"><font face="Tahoma" size="2">Closes the file specified by f.</font></p>
  <font face="Tahoma" size="2"><a name="SendConsoleCommand"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_SendConsoleCommand( int 
    exec_when, const char *text )<br>
    int exec_when: When to execute this command.<br>
    const char *text: The command to be executed.</font></p>
  <p align="left"><font face="Tahoma" size="2">This call adds a command to the 
    command buffer i.e. so that the programmer may issue server commands that 
    would normally need to be entered into the console. exec_when takes an element 
    of the cbufExec_t enumeration:</font></p>
  <p align="left"><font face="Tahoma" size="2"><br>
    code:<br>
    --------------------------------------------------------------------------------</font></p>
  <p align="left"><font face="Tahoma" size="2">// paramters for command buffer 
    stuffingtypedef enum { EXEC_NOW, // don't return until completed, a VM should 
    NEVER use this, // because some commands might cause the VM to be unloaded... 
    EXEC_INSERT, // insert at current position, but don't run yet EXEC_APPEND 
    // add to end of the command buffer (normal case)} cbufExec_t;</font></p>
  <p align="left"><font face="Tahoma" size="2">--------------------------------------------------------------------------------</font></p>
  <font face="Tahoma" size="2"><a name="LocateGameData"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_LocateGameData( gentity_t 
    *gEnts, int numGEntities, int sizeofGEntity_t, playerState_t *gameClients, 
    int sizeofGameClient )<br>
    gentity_t *gEnts: Usually level.gentities.<br>
    int numGEntities: Usually level.num_entities.<br>
    int sizeofGEntity_t: Usually sizeof( gentity_t ).<br>
    playerState_t *gameClients: Usually &amp;level.clients[0].ps.<br>
    int sizeofGameClient: Usually sizeof( level.clients[0] ).</font></p>
  <p align="left"><font face="Tahoma" size="2">It would be very unusual for a 
    mod programmer to want to call this - especially with parameters other than 
    those outlined above. Its purpose it to notify the Q3 binary when new entities 
    are created. In the Q3 source it is used twice - once on level load and in 
    G_Spawn where it is called whenever an entity is created. </font></p>
  <font face="Tahoma" size="2"><a name="DropClient"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_DropClient( int clientNum, 
    const char *reason )<br>
    int clientNum: The client to drop.<br>
    const char *reason: The reason for the drop.</font></p>
  <p align="left"><font face="Tahoma" size="2">This provides a mechanism to unconditionally 
    drop a client from a server via their clientNum ( ent-&gt;client-&gt;ps.clientNum). 
    The reason is displayed to the client when they are dropped.</font></p>
  <font face="Tahoma" size="2"><a name="SendServerCommand"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_SendServerCommand( int 
    clientNum, const char *text )<br>
    int clientNum: The client that the command is being sent from.<br>
    const char *text: The command to be sent.</font></p>
  <p align="left"><font face="Tahoma" size="2">This has the same effect as typing 
    a command in a clients console for evaluation by the server. This includes 
    the commands evaluated in g_cmds.c. Its main use in the Q3 source is to print 
    information to a specific client's console via the &quot;print&quot; command. 
    Passing -1 as the clientNum sends the command to every client.</font></p>
  <font face="Tahoma" size="2"><a name="LinkEntity"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_LinkEntity( gentity_t 
    *ent )<br>
    gentity_t *ent: Entity to be linked.</font></p>
  <p align="left"><font face="Tahoma" size="2">When an entity is &quot;linked&quot; 
    it is subject to all evaluations that the world performs on it. For example, 
    all linked entities are accounted for when performing a trace. Newly created 
    entities are not linked into the world - they must be explcitly linked using 
    this call. Linking an entity that is already linked into the world has no 
    effect.</font></p>
  <font face="Tahoma" size="2"><a name="UnlinkEntity"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_UnlinkEntity( gentity_t 
    *ent )<br>
    gentity_t *ent: Entity to be unlinked.</font></p>
  <p align="left"><font face="Tahoma" size="2">When an entity is &quot;unlinked&quot; 
    from the world it remains in memory, but ceases to exist from the point of 
    view of the world. This is useful for temporarily deleting an entity or when 
    performing major alterations to an entity's fields. Unlinking an entity that 
    is already unlinked has no effect.</font></p>
  <font face="Tahoma" size="2"><a name="InPVS"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">qboolean trap_InPVS( const vec3_t 
    p1, const vec3_t p2 )<br>
    const vec3_t p1: Absolute coordinates of point 1<br>
    const vec3_t p2:Absolute coordinates of point 2</font></p>
  <p align="left"><font face="Tahoma" size="2">Returns true if point1 can _potentially_ 
    see point2. Two points can return true, but not be visible to each other due 
    to detail brushes, curves, etc. A return value of false guarantees that the 
    points can not see each other. Normally used to test if two entities can potentially 
    see each other, point1 would be the currentOrigin of the first entitiy and 
    point2 the currentOrigin of the second entity. This function relies on the 
    Potentially Visible Set, and areaportal data generated during the BSP compiling 
    of a map. </font></p>
  <font face="Tahoma" size="2"><a name="InPVSIgnorePortals"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">qboolean trap_InPVSIgnorePortals( 
    const vec3_t p1, const vec3_t p2 )<br>
    const vec3_t p1: Absolute coordinates of point 1<br>
    const vec3_t p2: Absolute coordinates of point 2</font></p>
  <p align="left"><font face="Tahoma" size="2">Returns true if point1 can _potentially_ 
    see point2. This function does not check areaportals. Points hidden by closed 
    doors (and other areaportals) will still return true. </font></p>
  <font face="Tahoma" size="2"><a name="AdjustAreaPortalState"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_AdjustAreaPortalState( 
    gentity_t *ent, qboolean open )<br>
    gentity_t *ent: Entity to adjust<br>
    qboolean open: State to adjust to</font></p>
  <p align="left"><font face="Tahoma" size="2">Adjusts the state of a portal connecting 
    two areas. Set &quot;open&quot; to true to allow visibility through the portal 
    and false to block visibility. This is normally used to adjust visibility 
    when opening and closing doors. When the door is open; &quot;open&quot; is 
    set true and entities are visible through the door, when the door is closed; 
    &quot;open&quot; is set false and trap_InPVS will not see entities through 
    the door. See Use_BinaryMover in the game source for an example. </font></p>
  <font face="Tahoma" size="2"><a name="GetUserInfo"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_GetUserinfo( int num, 
    char *buffer, int bufferSize )<br>
    int num: clientNum of the userinfo to retrieve.<br>
    char *buffer: Pointer to a buffer to fill.<br>
    int buffersize: Size of the buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">Each client has a &quot;user info&quot; 
    string which is a backslash delimited key/value pair for the various options 
    the user can set. For example, model, skin and weapon colour. trap_GetUserinfo 
    fills the buffer pointed to by *buffer with the userinfo of the client referenced 
    by num. Key values are then retrieved using Info_ValueForKey( buffer, keyname 
    ).</font></p>
  <font face="Tahoma" size="2"><a name="SetUserinfo"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_SetUserinfo( int num, 
    const char *buffer )<br>
    int num: clientNum of userinfo to change.<br>
    const char *buffer: Userinfo string to set.</font></p>
  <p align="left"><font face="Tahoma" size="2">This does the opposite to trap_GetUserinfo 
    and sets a userinfo string for a user. However, it is not used much in the 
    Q3 source, where config strings seem to be the prefered method to transfer 
    userinfo to the client.</font></p>
  <p></p>
  <font face="Tahoma" size="2"><a name="GetServerinfo"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_GetServerinfo( char *buffer, 
    int bufferSize )<br>
    char *buffer: A buffer to fill with the server info.<br>
    int bufferSize: The size of the buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">The &quot;server info&quot; string 
    is a backslash delimited list of server variables such as g_gametype and mapname. 
    Besides the bot code, its only other use in the Q3 source is to print to the 
    value of serverinfo to the logfile.</font></p>
  <font face="Tahoma" size="2"><a name="AreasConnected"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">qboolean trap_AreasConnected( int 
    area1, int area2 )<br>
    int area1: First area to test.<br>
    int area2: Second area to test.</font></p>
  <p align="left"><font face="Tahoma" size="2">This functions tests whether or 
    not the areas (presumably leaf nodes of the bsp tree) are adjacent physically. 
    FIXME: the values of area1 and area2 are unknown, however.</font></p>
  <font face="Tahoma" size="2"><a name="EntityContactCapsule"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">qboolean trap_EntityContactCapsule( 
    const vec3_t mins, const vec3_t maxs, const gentity_t *ent )<br>
    const vec3_t mins: Lower bounds.<br>
    const vec3_t maxs: Upper bounds.<br>
    const gentity_t *ent: The entity to test.</font></p>
  <p align="left"><font face="Tahoma" size="2">If the entity pointed to by ent 
    is physically within the bounds specified by mins and maxs then this function 
    returns qtrue.</font></p>
  <font face="Tahoma" size="2"><a name="GetUsercmd"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_GetUsercmd( int clientNum, 
    usercmd_t *cmd )<br>
    int clientNum: The clientNum to retreive cmd from.<br>
    usercmd_t *cmd: Pointer to a usercmd_t to fill.</font></p>
  <p align="left"><font face="Tahoma" size="2">This function will retrieve the 
    usercmd_t generated by the client portion of the Q3 binary and place it in 
    what it pointed to by cmd.</font></p>
  <font face="Tahoma" size="2"><a name="GetEntityToken"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">qboolean trap_GetEntityToken( char 
    *buffer, int bufferSize )<br>
    char *buffer: A buffer to fill.<br>
    int bufferSize: The size of the buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">This call fills the buffer pointed 
    to by buffer with all the key/value pairs of every map entity. The string 
    returned has a very similar format to that of the tail end of a GTKRadiant 
    .map file before it is compiled to a bsp. It is unlikely that a user would 
    ever need to call this since it is handled already in g_spawn.c</font></p>
  <font face="Tahoma" size="2"><a name="GetFileList"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_FS_GetFileList( const 
    char *path, const char *extension, char *listbuf, int bufsize )<br>
    const char *path: String reflecting a directory.<br>
    const char *extension: File extension to list (incluing a leading period).<br>
    char *listbuf: Pointer to a buffer to fill.<br>
    int bufsize: Length of the buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">This fills listbuf with a NULL 
    delimited list of all the files in the directory specified by path ending 
    in extension. The number of files listed is returned.</font></p>
  <font face="Tahoma" size="2"><a name="DebugPolygonCreate"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_DebugPolygonCreate(int 
    color, int numPoints, vec3_t *points)<br>
    int color:<br>
    int numPoints:<br>
    vec3_t *points:</font></p>
  <p align="left"><font face="Tahoma" size="2">?</font></p>
  <p align="left"><font face="Tahoma" size="2">D!ABLO:<br>
    creates a solid coloured permanent polygon in the renderer (and world) based 
    on the given array of vertices/points.<br>
    it returns a reference handle to the polygon as it appears in the renderlist.<br>
    this function should be disabled, but it may still work.</font></p>
  <font face="Tahoma" size="2"><a name="DebugPolygonDelete"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_DebugPolygonDelete(int 
    id)<br>
    int id: a value previously returned by trap_DebugPolygonCreate</font></p>
  <p align="left"><font face="Tahoma" size="2">D!ABLO:<br>
    removes a polygon that was previously created via trap_DebugPolygonCreate.</font></p>
  <font face="Tahoma" size="2"><a name="SnapVector"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_SnapVector( float *v 
    )<br>
    float *v:Vector to snap.</font></p>
  <p align="left"><font face="Tahoma" size="2">This simply removes the fractional 
    part of each axis of v - a form of &quot;snap to grid&quot;. Its purpose is 
    to save network bandwidth by exploiting the fact that delta compression will 
    only transmit the changes in state of a struct. A changing vector will change 
    less frequently if only the integral part is taken into account.</font></p>
  <font face="Tahoma" size="2"><a name="RealTime"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_RealTime( qtime_t *qtime 
    )<br>
    qtime_t *qtime: Point in time - look at q_shared.h qtime_t for details.</font></p>
  <p align="left"><font face="Tahoma" size="2">Returns current system time and 
    date at server.</font></p>
  <font face="Tahoma" size="2"><a name="PlayCinematic"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">int trap_CIN_PlayCinematic( const 
    char *arg0, int xpos, int ypos, int width, int height, int bits);<br>
    arg0 - the name of the .RoQ file to load.</font></p>
  <p align="left"><font face="Tahoma" size="2">xpos - the X coordinate on-screen 
    for the left edge of the cinematic display.</font></p>
  <p align="left"><font face="Tahoma" size="2">ypos - the Y coordinate on-screen 
    for the top edge of the cinematic display.</font></p>
  <p align="left"><font face="Tahoma" size="2">width - the screen width of the 
    cinematic display.</font></p>
  <p align="left"><font face="Tahoma" size="2">height - the screen height of the 
    cinematic display.</font></p>
  <p align="left"><font face="Tahoma" size="2">bits - combinations of the following 
    flags:</font></p>
  <p align="left"><font face="Tahoma" size="2"><br>
    CIN_system</font></p>
  <p align="left"><font face="Tahoma" size="2">CIN_loop</font></p>
  <p align="left"><font face="Tahoma" size="2">CIN_hold</font></p>
  <p align="left"><font face="Tahoma" size="2">CIN_silent</font></p>
  <p align="left"><font face="Tahoma" size="2">CIN_shader<br>
    OR them together to use multiple. eg. CIN_loop|CIN_silent<br>
    this function loads up and begins playing an ROQ file at the coordinates given. 
    if the CIN_hold flag is specified, the ROQ is loaded in a paused state. the 
    function returns a handle to the cinematic instance or zero on failure.</font></p>
  <p align="left"></p>
  <font face="Tahoma" size="2"><a name="StopCinematic"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">e_status trap_CIN_StopCinematic(int 
    handle);<br>
    handle - the handle returned by a previous call to trap_CIN_PlayCinematic</font></p>
  <p align="left"><font face="Tahoma" size="2">from the code:<br>
    stops playing the cinematic and ends it. should always return FMV_EOF<br>
    cinematics must be stopped in reverse order of when they are started</font></p>
  <font face="Tahoma" size="2"><a name="RunCinematic"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">e_status trap_CIN_RunCinematic(int 
    handle);<br>
    handle a handle returned by a previous call to trap_CIN_PlayCinematic </font></p>
  <p align="left"><font face="Tahoma" size="2">from the code:<br>
    will run a frame of the cinematic but will not draw it. Will return FMV_EOF 
    if the end of the cinematic has been reached.</font></p>
  <font face="Tahoma" size="2"><a name="DrawCinematic"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_CIN_DrawCinematic (int 
    handle);<br>
    handle - a handle returned by a previous call to trap_CIN_PlayCinematic</font></p>
  <p align="left"><font face="Tahoma" size="2">this function renders the current 
    frame of the cinematic to the screen with the current position coordinates.</font></p>
  <font face="Tahoma" size="2"><a name="SetExtents"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_CIN_SetExtents (int handle, 
    int x, int y, int w, int h);<br>
    handle - a handle returned by a previous call to trap_CIN_PlayCinematic</font></p>
  <p align="left"><font face="Tahoma" size="2">x - the new X coordinate on-screen 
    of the left edge of the cinematic.</font></p>
  <p align="left"><font face="Tahoma" size="2">y - the new Y coordinate on-screen 
    of the top edge of the cinematic.</font></p>
  <p align="left"><font face="Tahoma" size="2">w - the new width on-screen of 
    the cinematic.</font></p>
  <p align="left"><font face="Tahoma" size="2">h - the new height on-screen of 
    the cinematic.</font></p>
  <p align="left"><font face="Tahoma" size="2">from the code:<br>
    allows you to resize the animation dynamically</font></p>
  <font face="Tahoma" size="2"><a name="VariableStringBuffer"></a> </font> 
  <hr>
  <p align="left"><font face="Tahoma" size="2">void trap_Cvar_VariableStringBuffer(const 
    char *var_name, char *buffer, int bufsize)<br>
    var_name: name of cvar (console variable).<br>
    buffer: destination string buffer.<br>
    bufsize: maximum limit of string buffer.</font></p>
  <p align="left"><font face="Tahoma" size="2">This trap copies the content of 
    a cvar named by var_name into a mod-space string. This is useful for obtaining 
    cvar contents that are not bound, or cannot be bound, to a vmCvar_t variable 
    in the mod code.</font></p>
  <p align="left"><font face="Tahoma" size="2">The terminating NULL is attached 
    to the end of the copied string by this trap, guaranteeing buffer holds a 
    null-terminated string. The total number of characters copied, including terminating 
    NULL, fits within the size specified by bufsize, truncating the string if 
    necessary.</font></p>
  <p align="left"><font face="Tahoma" size="2">A nonexistent cvar provides an 
    empty string. An existing cvar with empty content also provides an empty string. 
    Thus, this trap is not sufficient to determine if a cvar actually exists or 
    not.</font></p>
  <p align="left"><font face="Tahoma" size="2">This trap does not create a new 
    cvar; to create a new cvar during run-time, you can use trap_Cvar_Set or trap_SendConsoleCommand.</font></p>
  <hr>
  <p align="left"><font face="Tahoma" size="2">// EOF : For now , will be completed.</font></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p align="left"></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p align="left">&nbsp;</p>
  <p></p>
  <p>&nbsp;</p>
  <p></p>
  <p></p>
  <p><br>
    <br>
    <br>
  </p>
</div>
</body>
</html>
